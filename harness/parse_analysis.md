# Parsing static Analysis Output

This disgusting piece of python takes any output generated by Phenomenon or other tools + preprocessing output (library and offset) and parses it to the harness_generation_callsequences dictionary format, expected by the harness generation code.

The harness_generaton_callsequences maps the native functions to a callsequence, with themselves as the last function.

Example for the addJNI function in com.exmaple.hellolibs.MainActivity. The callsequence in this example is onCreateActivityJNI, onStartActivityJNI, addJNI. Each function in the list has a signature, containing the list of arguments, the return type as well as the library name and offset.

Each argument in the argument list has a type and may have a number of constraints associated with it.

The data dependencies dictionary may hold a mapping of function parameter at index to output of previoius function at index.

```json
"Java_com_example_hellolibs_MainActivity_addJNI": 
[{"name": "Java_com_example_hellolibs_MainActivity_onCreateActivityJNI", "signature": {"ret_type": "void", "args": [], "library": "libhello-libs.so", "offset": "401500"}, "data_dependencies": {}}, 
{"name": "Java_com_example_hellolibs_MainActivity_onStartActivityJNI", "signature": {"ret_type": "void", "args": [], "library": "libhello-libs.so", "offset": "401444"}, "data_dependencies": {}}, 
{"name": "Java_com_example_hellolibs_MainActivity_addJNI", "signature": {"ret_type": "jint", "args": [{"type": "jint", "constraints": {"equals": "1234"}}], "library": "libhello-libs.so", "offset": "402072"}, "data_dependencies": {}}]
```

## Intermediate formats

To generate the harness_generation_callsequences two intermediate formats are generated from the analysis output and then merged.

The first one is the **callgraph**, containing the callsequence for a function.

For the example above: (the data dependencies have been added). In this example the second argument of addJNI depends on the output of the onStartActivityJNI function and the 4th argument on the ouptut of onCreateActivityJNI. The first function called is at index 0 in the sequence list, last one at index -1.

```json
{
    "Java_com_example_hellolibs_MainActivity_addJNI":
    {"sequence": 
      ["Java_com_example_hellolibs_MainActivity_onCreateActivityJNI", "Java_com_example_hellolibs_MainActivity_onStartActivityJNI"],
      "data_dependencies": {
        "1": "1",
        "3": "0"
      }
    }
}
```

Intermediate formats also have some inline info about the reason why it's there

The second format is **fname2signature**, mapping functions to their signatures. Example for addJNI.

```json
{
  "Java_com_example_hellolibs_MainActivity_addJNI":
  {"ret_type": "jint", "args": [{"type": "jint", "constraints": {"equals": "1234"}}
}
```

The formats are merged in `merge_callsequence_signature_for_function`.

Both formats are generated by the functions in parse_analysis.py.
- `generate_argument_constraints_simple`: use the simple argument constraints (static_analysis/simple_argument_constraints.txt to generate the fname2signature dictionary
- `generate_argument_constraints_basic`: generate simple arguments (no constraints) for the fname2signature dictionary
- `generate_argument_constraints_phenomenon`: use phenonmenon constraints to generate the fname2signature dictionary
- `generate_empty_callsequence`: generates an empty callsequence for every function 
- `generate_callsequence_simple`: uses the simple callsequence from (static_analysis/simple_native_in_constructor.txt and static_analysis/simple_native_in_lifecycle.txt) to generate the callsequence
- `generate_callsequence_phenomenon`: generate the callsequence using the phenomenon output
- `generate_callsequence_data_heuristic`: enrich the existing callsequence with some data dependency heuristics (look for long functions)

To associate native calls with each other their class is used. Native functions in the same class are assumed to be connected and will thus be added to the corresponding callsequences.

## Pseudocode

### Callsequence

First the callsequence is generated: 

```python
callsequence = generate_argument_constraints_basic(app)
```

Now the callsequence contains just the skeleton (empty callseqeunce) for each native function in signatures_libraries_offsets.txt.

```python
if phenom_callsequence:
  callsequence = generate_callsequence_phenomenon(app, callsequence)
```

If phenom_callsequence then the callsequence contains the callsequences from phenomenon. Note that we only add native functions from the same class to the callseqeunces. (Same for all callseqeunce functions)

```python
if simple_constructor:
  callsequence = generate_callsequence_constructor(app, callsequence)
```

If simple_constructor then native calls observed in the constructor of the native function's class are prepended to the existing callsequence.

```python
if simple_lifecycle:
  callsequence = generate_callsequence_lifecycle(app, callsequence)
```
If simple_lifecycle then native calls observed in lifecycle functions are prepended to the existing callsequence. The order (last to first) is the following: 
`"android.content.ContentProvider", "android.app.Service","android.app.Fragment", "android.app.Activity"`

```python
if data_heuristic:
  callsequence = generate_callsequence_data_heuristic(app, callsequence)
```

if data_heuristic then we look at the existing functions in the callsequence and try to fulfill data dependencies based on the return values of native functions in the same class not yet in the callsequence. Ex: Argument is a long -> look for a function with a long and add it to the callsequence. The added functions are inserted at the earliest possible point (just above the first function with the data dependency)

### Constraints (Fname2Signature)

```python
fname2signature = generate_argument_constraints_basic(app)
```

This just generates the skeleton dict containing the signature information + library and offset.

```python
if with_simple_constraints:
  fname2singature = enrich_argument_constraints_simple(app, fname2siganture)
```

If with simple constraints, enriches the fname2signature with the simple constraints form the shallow flowdroid pass.

```python
if with_phenom_constraints:
  fname2singature = enrich_argument_constraints_phenom(app, fname2siganture)
```

**NOT IMPLMENTED** if with_phenom_constraints, enriches the constraints with phenomenon constraints.

```python
if with_argument_heuristics:
  fname2singature = enrich_argument_constraints_heuristic(app, fname2siganture)
```

Uses heuristics based on the function name + arg type to infer some very hard to extract constraints. (Like string == filepath for functions with File in the name)

### Harness_Generation_Callsequence

```python
for f in fname2signature:
        f_harness_callsequence = merge_callsequence_signature_for_function(f, callsequence[f], fname2signature)
```

Build the dict for the harness generator by merging fname2signature and callsequence.

```python
if with_io_matching:
  for f in f_harness_callsequence:
        f_harness_callsequence = io_matching(f, f_harness_callsequence[f])
```

**NOT IMPLEMENTED** if input/output matching, look through the generated callsequences and try to match function outputs to inputs. This modifies the data dependency dict of the functions in the callsequences.

```python
harness_callseqeuence = purge_non_supp_args(harness_callsequence)
```

**NOT IMPLEMENTED** (currently part of the merging) after all the steps purge the callsequences/functions with unsupported argument types.

```python
harness_callseqeuence = add_nocov_cs(harness_callsequence)
```

Add the harness generation callsequences for harnesses that will use the non-instrumented libraries. (For debugging/testing purposes)

## Limitations

Currently if we have constraints for a function, this function is always called with the constraints. Here constraint is equals 22 -> so this TestInit in the harness is always called with 22, even though in this constructor for the class one argument is dynamic.

```java
Test(int i){
            this.test = TestInit(22);
            TestInit(i);
        }
```